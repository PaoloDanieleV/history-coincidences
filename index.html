<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Historical Figures Coincidence Map</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin:0; font-family:Arial,Helvetica,sans-serif; background:#f4f4f4; }
    h1 { text-align:center; margin:15px 0; color:#333; }
    #map { height:70vh; width:100%; }
    .controls { padding:12px; text-align:center; background:#fff; }
    #yearLabel { font-weight:bold; font-size:1.2em; color:#d00; }
    #alert { text-align:center; padding:8px; background:#ffeb3b; display:none; margin:5px 0; }
    .note { font-size:0.9em; margin:8px 0; color:#555; }
  </style>
</head>
<body>

  <h1>Historical Figures Coincidence Map</h1>
  <div id="alert"></div>
  <div id="map"></div>

  <div class="controls">
    <input type="range" id="yearSlider" min="1800" max="2025" value="1913" step="1" style="width:80%;" />
    <div>Year: <span id="yearLabel">1913</span></div>
    <p class="note">Slide to see where people were – gaps are filled automatically.</p>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- PapaParse for CSV -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    // ---------- 1. MAP SETUP ----------
    const map = L.map('map').setView([48.2082, 16.3738], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const markers = L.layerGroup().addTo(map);
    const alertDiv = document.getElementById('alert');

    // ---------- 2. LOAD GOOGLE SHEET ----------
    // -----> REPLACE THIS LINE WITH YOUR PUBLISHED CSV URL <-----
    const sheetURL = "YOUR_GOOGLE_SHEET_CSV_LINK_HERE";

    let rawData = [];   // all rows from CSV

    Papa.parse(sheetURL, {
      download: true,
      header: true,
      complete: function(results) {
        rawData = results.data.filter(r => r.Name && r.Year && r.Lat && r.Long);
        // start with the slider value
        updateMap(parseInt(document.getElementById('yearSlider').value));
      },
      error: function(err) {
        alertDiv.style.display = 'block';
        alertDiv.style.background = '#f88';
        alertDiv.textContent = 'Error loading CSV – check the URL.';
      }
    });

    // ---------- 3. SLIDER ----------
    const slider = document.getElementById('yearSlider');
    const yearLabel = document.getElementById('yearLabel');

    slider.oninput = function () {
      const y = parseInt(this.value);
      yearLabel.textContent = y;
      updateMap(y);
    };

    // ---------- 4. GAP-FILLING UPDATE ----------
    function updateMap(selectedYear) {
      markers.clearLayers();

      // Group by person
      const people = {};
      rawData.forEach(row => {
        const name = row.Name.trim();
        if (!people[name]) people[name] = [];
        people[name].push({
          year: parseInt(row.Year),
          lat: parseFloat(row.Lat),
          lng: parseFloat(row.Long),
          bio: row.Bio || '',
          source: row.Source || '#'
        });
      });

      const visible = [];

      Object.keys(people).forEach(name => {
        const timeline = people[name].sort((a,b) => a.year - b.year);
        let current = null;

        for (let i = 0; i < timeline.length; i++) {
          const p = timeline[i];
          if (p.year === selectedYear) { current = p; break; }
          if (p.year < selectedYear) {
            // still at last known location until next entry
            if (!timeline[i+1] || timeline[i+1].year > selectedYear) {
              current = p;
              break;
            }
          }
        }
        if (current) visible.push({ name, ...current });
      });

      // ---- Add markers ----
      visible.forEach(p => {
        const m = L.circleMarker([p.lat, p.lng], {
          radius: 9,
          color: '#d00',
          fillOpacity: 0.9
        }).addTo(markers);

        m.bindPopup(`
          <b>${p.name}</b> (${selectedYear})<br>
          ${p.bio}<br>
          <a href="${p.source}" target="_blank">Source</a>
        `);
      });

      // ---- Coincidence alert ----
      if (visible.length > 1) {
        alertDiv.style.display = 'block';
        alertDiv.textContent = `Coincidence! ${visible.length} figures in ${selectedYear}`;
      } else {
        alertDiv.style.display = 'none';
      }

      // ---- Auto-zoom ----
      if (visible.length > 0) {
        const group = new L.featureGroup(visible.map(p => L.circleMarker([p.lat, p.lng])));
        map.fitBounds(group.getBounds().pad(0.5));
      } else {
        map.setView([0, 0], 2);
      }
    }
  </script>
</body>
</html>
